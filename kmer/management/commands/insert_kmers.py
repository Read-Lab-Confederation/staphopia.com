""" Insert Jellyfish output into the database. """
import sys
import time
import datetime

from bitarray import bitarray

from django.db import connection, transaction
from django.core.management.base import BaseCommand, CommandError

from sample.models import MetaData
from kmer.models import Binary, Total
from staphopia.utils import gziplines, timeit


class Command(BaseCommand):
    help = 'Insert Kmer data generated by Jellyfish into the database.'

    _code = {
        'A': bitarray('01'),
        'C': bitarray('11'),
        'G': bitarray('00'),
        'T': bitarray('10')
    }

    _tables = [
        'kmer_binarytmp',
        'kmer_count',
        'kmer_total',
        'kmer_counttemporary'
    ]

    def add_arguments(self, parser):
        parser.add_argument('sample_tag', metavar='SAMPLE_TAG',
                            help='Sample tag of the data.')
        parser.add_argument('jellyfish', metavar='JELLYFISH_COUNTS',
                            help=('Compressed (gzip) Jellyfish counts to be '
                                  'inserted.'))
        parser.add_argument('--size', type=int, default=500,
                            help='Size of each batch. (Default: 500)')
        parser.add_argument('--exists', action='store_true',
                            help=('Assume the kmer already exists in the '
                                  'database.'))
        parser.add_argument('--empty', action='store_true',
                            help='Empty tables and reset counts.')

    def handle(self, *args, **opts):
        if opts['empty']:
            # Empty Tables
            self.empty_tables()
            sys.exit()

        # Get Sample instance
        try:
            self.sample = MetaData.objects.get(sample_tag=opts['sample_tag'])
        except MetaData.DoesNotExist:
            raise CommandError('sample_tag {0} does not exist'.format(
                opts['sample_tag']
            ))

        # Inititalize values
        self.multiplier = 10
        self.total = 0
        self.singletons = 0
        self.kmer_counts = {}
        self.kmer_binary = []
        self.new_kmers = 0
        start_time = time.time()

        # Read Jellyfish file
        self.read_jellyfish_counts(opts['jellyfish'])
        print 'Total kmers: {0}'.format(self.total)
        self.encode_words(self.kmer_counts.keys())

        # Split encoded words into batches
        progress = 0
        progress_time = time.time()
        for batch in self.batches(self.encoded_words.keys(), opts['size']):
            values = None
            if opts['exists']:
                self.get_kmer_ids(batch, opts['exists'])
            else:
                self.insert_kmer(batch)
                self.get_kmer_ids(batch, opts['exists'])

            values = self.get_count_values()
            self.insert_counts(values)

            progress += opts['size']
            if progress % (opts['size'] * self.multiplier) == 0:
                self.print_progress(
                    opts['size'],
                    float(time.time() - progress_time),
                    progress
                )
                progress_time = time.time()

        # Process remaining kmers and insert totals
        runtime = int(time.time() - start_time)
        Total.objects.create(
            sample=self.sample,
            total=self.total,
            singletons=self.singletons,
            new_kmers=self.new_kmers,
            runtime=runtime
        )

    def print_progress(self, size, run_time, progress):
        total_remaining = ((self.total - progress) / (size * self.multiplier))
        time_left = run_time * total_remaining
        print('Progess {0} of {1} ({2:.2f}%, {3} kmers/sec) inserted. '
              'Estimated time remaining: {4}').format(
            progress,
            self.total,
            (float(progress) / self.total * 100),
            int((size * self.multiplier) / run_time),
            datetime.timedelta(seconds=time_left)
        )

    def encode(self, seq):
        a = bitarray()
        a.encode(self._code, seq)
        return a.tobytes()

    def decode(self, seq):
        a = bitarray()
        a.frombytes(seq)
        return a.decode(self._code)[0:31]

    def batches(self, l, n):
        """ Yield successive n-sized batches from l. """
        for i in xrange(0, len(l), n):
            yield l[i:i + n]

    @timeit
    def read_jellyfish_counts(self, jellyfish_file):
        for line in gziplines(jellyfish_file):
            word, count = line.rstrip().split(' ')
            self.kmer_counts[word] = int(count)

            # increment totals
            self.total += 1
            if int(count) == 1:
                self.singletons += 1

    @timeit
    def encode_words(self, words):
        # Encode kmers
        self.encoded_words = {}
        for word in words:
            self.encoded_words[self.encode(word)] = word

    @timeit
    def insert_kmer(self, words):
        # Insert bit encoded kmers
        self.new_kmers += Binary.objects.bulk_create_new(words)

        return None

    @timeit
    def get_kmer_ids(self, words, existing):
        if existing:
            self.kmer_ids = Binary.objects.in_bulk_existing(words)
        else:
            self.kmer_ids = {}
            query = """
                SELECT b.id, b.string
                FROM kmer_binarytmp AS tmp
                LEFT JOIN kmer_binary AS b
                ON b.string=tmp.string;
                """
            cursor = connection.cursor()
            cursor.execute(query)

            for row in cursor.fetchall():
                self.kmer_ids[str(row[1])] = row[0]

        return None

    @timeit
    def get_count_values(self):
        values = []
        for string, string_id in self.kmer_ids.items():
            # count, sample_id, string_id
            values.append('({0}, {1}, {2})'.format(
                self.kmer_counts[self.encoded_words[string]],
                self.sample.pk,
                string_id
            ))

        return values

    @timeit
    def insert_counts(self, values):
        query = (
            "INSERT INTO kmer_counttemporary (count, sample_id, string_id) "
            "VALUES {0}".format(','.join(values))
        )
        cursor = connection.cursor()
        cursor.execute(query)

    @transaction.atomic
    def empty_tables(self):
        # Empty Tables and Reset id counters to 1
        for table in self._tables:
            self.empty_table(table)

    def empty_table(self, table):
        query = "TRUNCATE TABLE {0} RESTART IDENTITY CASCADE;".format(table)
        cursor = connection.cursor()
        cursor.execute(query)
